{"version":3,"sources":["Card.js","GuessCount.js","HallOfFame.js","HighScoreInput.js","App.js","reportWebVitals.js","index.js"],"names":["Card","card","feedback","index","onClick","onKeyPress","className","role","tabIndex","e","GuessCount","guesses","HallOfFame","entries","map","date","id","player","HOF_KEY","HighScoreInput","props","handleWinnerUpdate","event","setState","winner","target","value","toUpperCase","persistWinner","preventDefault","onStored","entry","newEntry","Date","toLocaleDateString","now","JSON","parse","localStorage","getItem","insertionPoint","findIndex","_entry","push","splice","length","setItem","stringify","saveHOFEntry","state","this","onSubmit","htmlFor","autoComplete","onChange","type","placeholder","required","Component","App","handleCardClick","currentPair","handleNewPair","handleKeyPress","key","displayHallOfFame","hallOfFame","cards","generateCards","matchedCardIndices","feedbacks","Array","SIDE","fill","result","candidates","from","pop","shuffle","newPair","newGuesses","matched","setTimeout","indexMatched","includes","currentFeedback","newFeedback","won","table","copyCards","row","iRow","iCol","getFeedbackForCard","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.85a4ee6c.chunk.js","sourcesContent":["import PropTypes from 'prop-types'\nimport React from 'react'\n\nimport './Card.css'\n\nexport const HIDDEN_SYMBOL = '❓'\n\n/**\n * Display a card on the screen\n * @component\n * @prop {string} card Content of the card\n * @prop {string} feedback Feeback of the card\n * (See possible feedback values in {@link Card}.propTypes)\n * @prop {number} index Index of the card\n * @prop {function} onClick Function called when the card is clicked on\n * @prop {function} onKeyPress Function called a card has the focus and a keyboard key is pressed\n * @returns {JSX} Information to display on the screen\n */\nconst Card = ({\n    card, feedback, index, onClick, onKeyPress,\n}) => (\n    <div\n        className={`card ${feedback}`}\n        role=\"button\"\n        tabIndex={0} // a value of zero indicates that this element can be tabbed to\n        onClick={() => onClick(index)}\n        onKeyPress={(e) => onKeyPress(e, onClick, index, feedback)}\n    >\n        <span className=\"symbol\">{feedback === 'hidden' ? HIDDEN_SYMBOL : card}</span>\n    </div>\n)\n\nCard.propTypes = {\n    card: PropTypes.string.isRequired,\n    feedback: PropTypes.oneOf([\n        'visible',\n        'hidden',\n        'justMatched',\n        'justMismatched',\n        'disabled',\n    ]).isRequired,\n    index: PropTypes.number.isRequired,\n    onClick: PropTypes.func.isRequired,\n    onKeyPress: PropTypes.func.isRequired,\n}\n\nexport default Card\n","import PropTypes from 'prop-types'\nimport React from 'react'\n\nimport './GuessCount.css'\n\n/**\n * Dislay the number of guesses done by the user\n * @component\n * @prop {number} guesses Number of guesses done by the user\n * @returns {JSX} Information to display on the screen\n */\nconst GuessCount = ({ guesses }) => <div className=\"guesses\">{`Number of guesses: ${guesses}`}</div>\n\n// GuessCount.defaultProps = {\n//     guesses: 0,\n// }\n\nGuessCount.propTypes = {\n    guesses: PropTypes.number.isRequired,\n}\n\nexport default GuessCount\n","import PropTypes from 'prop-types'\nimport React from 'react'\n\nimport './HallOfFame.css'\n\n/**\n * Display information about the winners\n * @component\n * @prop {JSON} entries Information about the winners (See values in {@link HallOfFame}.propTypes)\n * @returns {JSX} Information to display on the screen\n */\nconst HallOfFame = ({ entries }) => (\n    <table className=\"hallOfFame\">\n        <thead>\n            <tr>\n                <th>Date</th>\n                <th>Guesses</th>\n                <th>Player</th>\n            </tr>\n        </thead>\n        <tbody>\n            {entries.map(({\n                date, guesses, id, player,\n            }) => (\n                <tr key={id}>\n                    <td className=\"date\">{date}</td>\n                    <td className=\"guesses\">{guesses}</td>\n                    <td className=\"player\">{player}</td>\n                </tr>\n            ))}\n        </tbody>\n    </table>\n)\n\nHallOfFame.propTypes = {\n    entries: PropTypes.arrayOf(\n        PropTypes.shape({\n            date: PropTypes.string.isRequired,\n            guesses: PropTypes.number.isRequired,\n            id: PropTypes.number.isRequired,\n            player: PropTypes.string.isRequired,\n        }),\n    ).isRequired,\n}\n\nexport default HallOfFame\n\n// ===== Internal helpers =====\n\nexport const HOF_KEY = '::Memory::HallOfFame'\nexport const HOF_MAX_SIZE = 10 // limit the number of winners to HOF_MAX_SIZE in the HallOfFame\n\n/**\n * Save information about a player\n * @param {JSON} entry Information about a player (See parameter given\n * in code of function {@link HighScoreInput#persistWinner})\n * @param {function} onStored Function called after information\n * is stored in order to display information about the winners\n * (See parameter given in code of function {@link HighScoreInput#persistWinner})\n */\nexport function saveHOFEntry(entry, onStored) {\n    const { guesses, player } = entry\n    const date = new Date().toLocaleDateString()\n    const id = Date.now()\n    const newEntry = {\n        guesses, player, date, id,\n    }\n\n    const entries = JSON.parse(localStorage.getItem(HOF_KEY) || '[]')\n\n    const insertionPoint = entries.findIndex(\n        (_entry) => _entry.guesses >= newEntry.guesses,\n    )\n    // findIndex does not execute the function for array elements without values\n    // i.e. when entries === []\n\n    if (insertionPoint === -1) {\n        entries.push(newEntry)\n    } else {\n        entries.splice(insertionPoint, 0, newEntry)\n    }\n    if (entries.length > HOF_MAX_SIZE) {\n        entries.splice(HOF_MAX_SIZE, entries.length)\n    }\n    localStorage.setItem(HOF_KEY, JSON.stringify(entries))\n    onStored(entries)\n}\n\n/**\n * <p>Empty storage that contains Hall Of Fame</p>\n * <p>This function is used in test files to reset\n * the value of the local storage to make each test independent\n * of one another</p>\n */\nexport function emptyHOF() {\n    localStorage.setItem(HOF_KEY, '[]')\n}\n","import PropTypes from 'prop-types'\nimport React, { Component } from 'react'\n\nimport './HighScoreInput.css'\n\nimport { saveHOFEntry } from './HallOfFame'\n\n/**\n * Get winner information, save it and display it\n * @component\n * @prop {number} guesses Number of guesses done by the user\n * @prop {function} onStored Function called after information is stored\n * in order to display information about the winners (See {@link App#displayHallOfFame})\n * @extends {Component}\n */\nclass HighScoreInput extends Component {\n    constructor(props) {\n        super(props)\n        this.state = { winner: '' }\n    }\n\n    /**\n     * <p>Handle onChange event from user input</p>\n     * <p>Transform lower case letters to upper case</p>\n     * @param {event} event onChange event\n     */\n    // Arrow function for binding\n    handleWinnerUpdate = (event) => {\n        this.setState({ winner: event.target.value.toUpperCase() })\n    }\n\n    /**\n     * <p>Handle onSubmit event after the winner submits his information</p>\n     * @param {event} event onSubmit event\n     */\n    // Arrow function for binding\n    persistWinner = (event) => {\n        event.preventDefault()\n        const { guesses, onStored } = this.props\n        const { winner } = this.state\n        const newEntry = { guesses, player: winner }\n        saveHOFEntry(newEntry, onStored)\n    }\n\n    /**\n     * Render the winner information form\n     */\n    render() {\n        const { winner } = this.state\n        return (\n            <form className=\"highScoreInput\" onSubmit={this.persistWinner}>\n                <p>\n                    <label htmlFor=\"input_winner_information\">\n                        Well done!\n                        <input\n                            autoComplete=\"given-name\"\n                            onChange={this.handleWinnerUpdate}\n                            type=\"text\"\n                            value={winner}\n                            id=\"input_winner_information\"\n                            placeholder=\"Enter your name\"\n                            required\n                        />\n                    </label>\n                    <button type=\"submit\">You have won!</button>\n                </p>\n            </form>\n        )\n    }\n}\n\nHighScoreInput.propTypes = {\n    guesses: PropTypes.number.isRequired,\n    onStored: PropTypes.func.isRequired,\n}\n\nexport default HighScoreInput\n","import React, { Component } from 'react'\nimport shuffle from 'lodash.shuffle'\n\nimport './App.css'\n\nimport Card from './Card'\nimport GuessCount from './GuessCount'\nimport HallOfFame from './HallOfFame'\nimport HighScoreInput from './HighScoreInput'\n\n// SIDE * SIDE should be an even number as each card must be present twice to make pairs\nexport const SIDE = 2\nexport const SYMBOLS = '😀🎉💖🎩🐶🐱🦄🐬🌍🌛🌞💫🍎🍌🍓🍐🍟🍿'\nexport const VISUAL_PAUSE_MSECS = 500\n\n/**\n * Memory app\n * @component\n * @extends {Component}\n */\nclass App extends Component {\n    /**\n     * Generate a shuffled array of pairs of cards\n     * @return {Array} Shuffled array of pairs of cards\n     */\n    static generateCards() {\n        const result = []\n        const size = SIDE * SIDE\n        const candidates = Array.from(SYMBOLS) // convert string to array of chars\n        // Keep this loop to control number of\n        // cards with variable SIDE\n        while (result.length < size) {\n            const card = candidates.pop()\n            result.push(card, card)\n        }\n        return shuffle(result)\n    }\n\n    constructor(props) {\n        super(props)\n        this.state = {\n            cards: App.generateCards(),\n            currentPair: [],\n            guesses: 0,\n            hallOfFame: null,\n            matchedCardIndices: [],\n        }\n        /**\n         * Initialize card feedbacks as hidden at the\n         * start of the game\n         */\n        this.feedbacks = Array(SIDE * SIDE).fill('hidden')\n    }\n\n    /**\n     * <p>Handle event when card is clicked on</p>\n     * @param {number} index Index of the card that was clicked on\n     */\n    // Arrow function for binding\n    handleCardClick = (index) => {\n        const { currentPair } = this.state\n\n        // Prevent user from clicking when\n        // the current pair already contains\n        // 2 cards\n        if (currentPair.length === 2) {\n            return\n        }\n\n        if (currentPair.length === 0) {\n            this.setState({ currentPair: [index] })\n            return\n        }\n        this.handleNewPair(index)\n    }\n\n    /**\n     * <p>Flip a card when the card is selected (with tab) and enter key is pressed</p>\n     * <p>The card can only be selected once (i.e. only if its current feedback is `hidden`)</p>\n     * @arg {Event} event onKeyPress event\n     * @arg {Event} onClick onClick event\n     * @arg {number} index Index of card that was clicked on\n     * @arg {string} feedback Feeback of the card\n     * (See possible feedback values in {@link Card}.propTypes)\n     */\n    // Arrow function for binding\n    handleKeyPress = (e, onClick, index, feedback) => {\n        if (e.key === 'Enter' && feedback === 'hidden') {\n            onClick(index)\n        }\n    }\n\n    /**\n     * Checking if both cards in the pair match\n     * @param {number} index Index of the card that was clicked on\n     */\n    handleNewPair(index) {\n        const {\n            cards, currentPair, guesses, matchedCardIndices,\n        } = this.state\n\n        const newPair = [currentPair[0], index]\n        const newGuesses = guesses + 1\n        const matched = cards[newPair[0]] === cards[newPair[1]]\n        this.setState({ currentPair: newPair, guesses: newGuesses })\n        if (matched) {\n            this.setState({ matchedCardIndices: [...matchedCardIndices, ...newPair] })\n        }\n        setTimeout(() => this.setState({ currentPair: [] }), VISUAL_PAUSE_MSECS)\n    }\n\n    /**\n     * <p>Get the feeback of a card</p>\n     * <p>See possible feedback values in {@link Card#propTypes}</p>\n     * The variable `currentPair` should at maximum contain two elements (i.e. a pair)\n     * @return {string} Feeback value\n     */\n    getFeedbackForCard(index) {\n        const { currentPair, matchedCardIndices } = this.state\n        const indexMatched = matchedCardIndices.includes(index)\n        const currentFeedback = this.feedbacks[index]\n        let newFeedback = ''\n\n        if (currentFeedback === 'justMatched' || currentFeedback === 'disabled') {\n            newFeedback = 'disabled'\n        } else if (currentPair.length < 2) {\n            newFeedback = currentPair.includes(index) ? 'visible' : 'hidden'\n        } else if (currentPair.includes(index)) {\n            // implicit (currentPair.length === 2) as a pair is at most composed of two elements\n            newFeedback = indexMatched ? 'justMatched' : 'justMismatched'\n        } else {\n            // implicit (currentPair.length === 2) as a pair is at most composed of two elements\n            newFeedback = indexMatched ? 'visible' : 'hidden'\n        }\n        this.feedbacks[index] = newFeedback\n        return newFeedback\n    }\n\n    /**\n     * <p>Display information about the winners</p>\n     * @param {HallOfFame} hallOfFame Information about the winners\n     */\n    // Arrow function for binding\n    // (i.e. to access `this` of the current object,\n    // instead of doing\n    // this.displayHallOfFame = this.displayHallOfFame.bind(this)\n    // in the constructor)\n    displayHallOfFame = (hallOfFame) => {\n        this.setState({ hallOfFame })\n        // where { hallOfFame } is shorthand for { hallOfFame: hallOfFame }\n    }\n\n    /**\n     * Render the whole game\n     */\n    render() {\n        const {\n            cards, guesses, hallOfFame, matchedCardIndices,\n        } = this.state\n        // Game is won when there are as many matched cards as there are cards\n        // in the game\n        const won = matchedCardIndices.length === cards.length\n        const table = []\n        const copyCards = [...cards]\n\n        // reshape 1D array to 2D array with SIDE rows\n        // and SIDE columns\n        while (copyCards.length) {\n            table.push(copyCards.splice(0, SIDE))\n        }\n        return (\n            <div className=\"memory\">\n                <GuessCount guesses={guesses} />\n                <table>\n                    <tbody>\n                        { table.map((row, iRow) => (\n                            <tr key={iRow}>\n                                { row.map((card, iCol) => {\n                                    const index = SIDE * iRow + iCol\n                                    return (\n                                        <td key={index}>\n                                            <Card\n                                                card={card}\n                                                feedback={this.getFeedbackForCard(index)}\n                                                key={index} // key must be unique and stable in time\n                                                index={index}\n                                                onClick={this.handleCardClick}\n                                                onKeyPress={this.handleKeyPress}\n                                            />\n                                        </td>\n                                    )\n                                })}\n                            </tr>\n                        ))}\n                    </tbody>\n                </table>\n                {won && (hallOfFame ? (<HallOfFame entries={hallOfFame} />\n                ) : (\n                    <HighScoreInput\n                        guesses={guesses}\n                        onStored={this.displayHallOfFame}\n                    />\n                ))}\n            </div>\n        )\n    }\n}\n\nexport default App\n","const reportWebVitals = (onPerfEntry) => {\n    if (onPerfEntry && onPerfEntry instanceof Function) {\n        import('web-vitals').then(({\n            getCLS, getFID, getFCP, getLCP, getTTFB,\n        }) => {\n            getCLS(onPerfEntry)\n            getFID(onPerfEntry)\n            getFCP(onPerfEntry)\n            getLCP(onPerfEntry)\n            getTTFB(onPerfEntry)\n        })\n    }\n}\n\nexport default reportWebVitals\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nimport reportWebVitals from './reportWebVitals'\n\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById('root'),\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}